#!/bin/bash
# position_app.sh - Launch an app, find the new window, and move/resize it.
# Requirements: xdotool, wmctrl
# Exit on errors in pipelines (SC2250)
set -o errexit -o nounset -o pipefail

# ------------- utils -------------
log() { printf '[%s] %s\n' "$(date '+%F %T')" "$*" >&2; }
die() { log "ERROR: $*"; command -v notify-send >/dev/null 2>&1 && notify-send "position_app.sh" "ERROR: $*" || true; exit 1; }

print_help() {
  cat <<EOF
Usage:
  ${FUNCNAME[0]/print_help/position_app.sh} [--command "<cmd>"] [--class <wmclass>] [--x-pct N] [--y-pct N] [--w-pct N] [--h-pct N]
  ${FUNCNAME[0]/print_help/position_app.sh} --preset third-bottom-left
  ${FUNCNAME[0]/print_help/position_app.sh} --help

Description:
  Launches a program, detects the newly created window (by WM_CLASS), and moves/resizes it.

Options:
  --command "<cmd>"    Command to launch (quoted). Default opens Sublime Text with scratch.md
  --class <wmclass>    Expected WM_CLASS (for xdotool --class). Default: sublime_text
  --x-pct N            Target X position as percent of screen width (0..100). Default: 0
  --y-pct N            Target Y position as percent of screen height (0..100). Default: 66
  --w-pct N            Target width as percent of screen width (1..100). Default: 33
  --h-pct N            Target height as percent of screen height (1..100). Default: 33
  --timeout <sec>      How long to wait for the new window. Default: 12
  --dry-run            Show what would happen without moving the window.
  --verbose            Verbose logging.
  --preset third-bottom-left
                       Convenience preset: x=0%, y=66%, w=33%, h=33%
  --help               Show this help.

Notes:
  * WM_CLASS can be checked with: wmctrl -lx | awk '{print \$3}' | sort -u
  * Works well with apps that set a stable WM_CLASS (Sublime: "sublime_text").
EOF
}

# ------------- defaults -------------
COMMAND='/usr/bin/subl --new-window --background "$HOME/scratch.md"'
WMCLASS='sublime_text'
X_PCT=0
Y_PCT=66
W_PCT=33
H_PCT=33
TIMEOUT=12
VERBOSE=0
DRYRUN=0

# ------------- args -------------
while [[ ${1-} ]]; do
  case "$1" in
    --command) shift; COMMAND="${1-}"; [[ -n "${COMMAND}" ]] || die "--command needs a value";;
    --class) shift; WMCLASS="${1-}"; [[ -n "${WMCLASS}" ]] || die "--class needs a value";;
    --x-pct) shift; X_PCT="${1-}";;
    --y-pct) shift; Y_PCT="${1-}";;
    --w-pct) shift; W_PCT="${1-}";;
    --h-pct) shift; H_PCT="${1-}";;
    --timeout) shift; TIMEOUT="${1-}";;
    --preset)
      shift
      case "${1-}" in
        third-bottom-left) X_PCT=0; Y_PCT=66; W_PCT=33; H_PCT=33;;
        top-left) X_PCT=0; Y_PCT=0; W_PCT=33; H_PCT=67;;
        right) X_PCT=33; Y_PCT=0; W_PCT=67; H_PCT=100;;
        *) die "Unknown preset: ${1-}";;
      esac
      ;;
    --dry-run) DRYRUN=1;;
    --verbose) VERBOSE=1;;
    --help|-h) print_help; exit 0;;
    *) die "Unknown option: $1 (use --help)";;
  esac
  shift || true
done

# ------------- checks -------------
command -v xdotool >/dev/null 2>&1 || die "xdotool not found"
command -v wmctrl  >/dev/null 2>&1 || die "wmctrl not found"

# Validate percentages 0..100
for v in X_PCT Y_PCT W_PCT H_PCT; do
  val="${!v}"
  [[ "${val}" =~ ^[0-9]+$ ]] || die "$v must be an integer 0..100"
  (( val >= 0 && val <= 100 )) || die "$v out of range: ${val}"
done
(( W_PCT > 0 && H_PCT > 0 )) || die "Width/Height must be > 0"

# ------------- helpers -------------
get_windows_by_class() {
  # Return window IDs (one per line) for a WM_CLASS
  xdotool search --class "${WMCLASS}" 2>/dev/null || true
}

percent_of() { # $1=value $2=percent -> integer pixels
  local value="$1" pct="$2"
  echo $(( value * pct / 100 ))
}

# ------------- capture pre-state -------------
PRE_IDS="$(get_windows_by_class | sort -u || true)"
[[ "${VERBOSE}" -eq 1 ]] && log "Pre-existing ${WMCLASS} windows: $(wc -l <<<"${PRE_IDS}")"

# ------------- launch -------------
[[ "${VERBOSE}" -eq 1 ]] && log "Launching: ${COMMAND}"
# Use bash -lc to honor quotes/expansions inside --command
bash -lc "${COMMAND}" >/dev/null 2>&1 &

# ------------- wait for new window -------------
WIN_ID=""
end=$(( SECONDS + TIMEOUT ))
while (( SECONDS < end )); do
  NOW_IDS="$(get_windows_by_class | sort -u || true)"
  # Find IDs present now but not before
  NEW_IDS="$(comm -13 <(printf '%s\n' "${PRE_IDS}") <(printf '%s\n' "${NOW_IDS}"))"
  if [[ -n "${NEW_IDS}" ]]; then
    # Pick the most recently mapped window (last line)
    WIN_ID="$(tail -n1 <<<"${NEW_IDS}")"
    [[ "${VERBOSE}" -eq 1 ]] && log "New window detected: ${WIN_ID}"
    break
  fi
  sleep 0.2
done

[[ -n "${WIN_ID}" ]] || die "Timed out after ${TIMEOUT}s waiting for a new ${WMCLASS} window"

# ------------- compute geometry -------------
read -r SW SH < <(xdotool getdisplaygeometry)
[[ "${VERBOSE}" -eq 1 ]] && log "Screen: ${SW}x${SH}"

W_PX="$(percent_of "${SW}" "${W_PCT}")"
H_PX="$(percent_of "${SH}" "${H_PCT}")"
X_PX="$(percent_of "${SW}" "${X_PCT}")"
Y_PX="$(percent_of "${SH}" "${Y_PCT}")"

[[ "${VERBOSE}" -eq 1 ]] && log "Target geom: x=${X_PX} y=${Y_PX} w=${W_PX} h=${H_PX}"

# ------------- move/resize -------------
if [[ "${DRYRUN}" -eq 1 ]]; then
  log "[DRY-RUN] wmctrl -i -r ${WIN_ID} -e 0,${X_PX},${Y_PX},${W_PX},${H_PX}"
  exit 0
fi

# Ensure the window is managed & visible before resizing
wmctrl -i -a "${WIN_ID}" || true
wmctrl -i -r "${WIN_ID}" -e "0,${X_PX},${Y_PX},${W_PX},${H_PX}" || die "Failed to move/resize window ${WIN_ID}"
[[ "${VERBOSE}" -eq 1 ]] && log "Done."
