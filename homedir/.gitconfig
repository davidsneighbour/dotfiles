[user]
	email = patrick@davids-neighbour.com
	name = Patrick Kollitsch
signingkey = 40BCAA0B2E3817F4

[apply]
# Detect whitespace errors when applying a patch
whitespace = fix

[credential]
helper = cache --timeout=3600

[core]
autocrlf = input

editor = subl -n -w
filemode = false

# Use 12 characters for the abbreviated commit hash. I can currently make
# do with 10, but this should provide a certain level of safety for the
# near-ish future. See the interesting and well-researched article at
# http://blog.cuviper.com/2013/11/10/how-short-can-git-abbreviate/
abbrev = 12

# Enable parallel I/O for operations like "git diff".
# See http://stackoverflow.com/q/18257622/276478
preloadindex = true

# Use custom `.gitignore` and `.gitattributes`
excludesfile = ~/.gitignore
attributesfile = ~/.gitattributes

# Treat spaces before tabs and all kinds of trailing whitespace as an error
# [default] trailing-space: looks for spaces at the end of a line
# [default] space-before-tab: looks for spaces before tabs at the beginning of a line
whitespace = space-before-tab,-indent-with-non-tab,trailing-space

# deltasetup
pager=delta

[diff]
# Use more time to create better diffs. E.g. matching opening/closing braces
# from neighbour functions.
algorithm = histogram

# Tells Git to detect renames. If set to "true", it will enable basic
# rename detection. If set to "copies", it will detect copies, as well.
renames = copies

[merge]
tool = meld

# When merging, add a list of merged commits to the autogenerated commit
# message.
log = true

[color]
diff = auto
stats = auto
branch = auto
ui = auto

[color.grep]
filename = bold green
match = black yellow

[color "branch"]
current = yellow reverse
local = yellow
remote = green

[color "diff"]
meta = yellow bold
frag = magenta bold # line info
old = red           # deletions
new = green         # additions

[color "status"]
added = yellow
changed = green
untracked = cyan

[push]
# Make "git push" or "git push <remote>" only push the current branch to
# the tracked branch (regardless of its remote name) as opposed to pushing
# all branches with a matching name on the remote. See "An asymmetry
# between git pull and push": http://longair.net/blog/?p=572
default = tracking

[help]
# Automatically correct and execute mistyped commands
autocorrect = 1

[alias]
commit = commit --signoff
# merge all commits of a branch into one single commit
squash-all = "!f(){ git reset $(git commit-tree HEAD^{tree} -m \"${1:-chore: initial commit}\");};f"

hist = log --graph --pretty=format:'%Cred%h%Creset %C(cyan)%an%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative
player = shortlog -sn
sneak = commit --amend --no-edit
co = checkout
ci = commit
st = status
br = branch
type = cat-file -t
dump = cat-file -p
lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
branchdate = !git for-each-ref --sort='-authordate' --format='%(refname)%09%(authordate)' refs/heads | sed -e 's-refs/heads/--'
lllllll = log --pretty=oneline --abbrev-commit --graph --decorate

# When doing "git git log" or some such, do not complain about "git" not
# being a valid Git command. This happens when copy-pasting examples, for
# instance.
git = !git

# Quickly view the latest commits using a helper script to massage the
# "git log" output.
l = tilde-log

# Like "git l", but show all and draw the history graph, too.
ll = tilde-log --graph

# Like "git l", but for the reflog.
rl = tilde-reflog

# Show a concise status of the working directory, along with the branch
# and the number of commits behind and/or ahead.
s = status --short --branch

# Show the staged changes.
dc = diff --cached

# Like "git show myfile", but uses the last commit that changed "myfile".
showlast = log -n 1 -p

# Switch branches, creating them if necessary. I want to unlearn using
# "git checkout" for switching between branches because of the possible
# dataloss when not paying attention. (You could see the PEBKAC, but I
# could reply with another four letter acronym, slightly resembling TOFU.)
#
# Suppose I have modified a file named "password" and have two branches,
# "password-expiry-mechanism" and "password-reset-mail". If I want to
# switch to either branch, I would type "git checkout pass<Tab><Enter>",
# but the autocomplete would stop at "git checkout password" because of
# the ambiguity. Because I press <Enter> without really thinking, I have
# now reset my "password" file. With "git go pass<Tab><Enter>", I would
# simply have created a new branch called "password". (I would be forced
# to use "--" to separate paths from banch names, which is a Good Thing™.)
go = checkout -B

# Make "git grep" look a bit like "ack"/"ag". Note that you need to
# specify --no-index to search all files, and that submodules are not
# searched.
ack = grep --extended-regexp --break --heading --line-number

# update submodules
update = submodule update --recursive --remote

# View abbreviated SHA, description, and history graph of the latest 20 commits
l = log --pretty=oneline -n 20 --graph --abbrev-commit

# View the current working tree status using the short format
s = status -s

# Show the diff between the latest commit and the current state
d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

# `git di $number` shows the diff between the state `$number` revisions ago and the current state
di = !"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"

# Pull in remote changes for the current repository and all its submodules
p = !"git pull; git submodule foreach git pull origin master"

# Clone a repository including all submodules
c = clone --recursive

# Commit all changes
ca = !git add -A && git commit -av

# Switch to a branch, creating it if necessary
go = "!f() { git checkout -b \"$1\" 2> /dev/null || git checkout \"$1\"; }; f"

# Show verbose output about tags, branches or remotes
tags = tag -l
branches = branch -a
remotes = remote -v

# Amend the currently staged files to the latest commit
amend = commit --amend --reuse-message=HEAD

# Credit an author on the latest commit
credit = "!f() { git commit --amend --author \"$1 <$2>\" -C HEAD; }; f"

# Interactive rebase with the given number of latest commits
reb = "!r() { git rebase -i HEAD~$1; }; r"

# Find branches containing commit
fb = "!f() { git branch -a --contains $1; }; f"

# Find tags containing commit
ft = "!f() { git describe --always --contains $1; }; f"

# Find commits by source code
fc = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short -S$1; }; f"

# Find commits by commit message
fm = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short --grep=$1; }; f"

# Remove branches that have already been merged with master
# a.k.a. ‘delete merged’
dm = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"

# List contributors with number of commits
contributors = shortlog --summary --numbered

# URL shorthands
[url "git@github.com:"]
insteadOf = "gh:"
pushInsteadOf = "github:"
pushInsteadOf = "git://github.com/"

[url "git://github.com/"]
insteadOf = "github:"

[url "git@gist.github.com:"]
insteadOf = "gst:"
pushInsteadOf = "gist:"
pushInsteadOf = "git://gist.github.com/"

[url "git://gist.github.com/"]
insteadOf = "gist:"

[url "git@heroku.com:"]
insteadOf = "heroku:"

[commit]
gpgsign = true
[pull]
rebase = true
[init]
defaultBranch = main

[includeIf "gitdir:~/work/"]
path = ~/.gitconfig.work

[interactive]
diffFilter = delta --color-only --features=interactive

[delta]
features = side-by-side line-numbers decorations
syntax-theme = Dracula
plus-style = syntax "#003800"
minus-style = normal "#3f0001"

[delta "interactive"]
keep-plus-minus-markers = false

[delta "decorations"]
commit-decoration-style = bold yellow box ul
commit-style = raw
file-style = bold yellow ul
file-decoration-style = none
hunk-header-decoration-style = cyan box ul
hunk-header-file-style = red
hunk-header-line-number-style = "#067a00"
hunk-header-style = file line-number syntax

[delta "line-numbers"]
line-numbers-left-style = cyan
line-numbers-right-style = cyan
line-numbers-minus-style = 124
line-numbers-plus-style = 28
